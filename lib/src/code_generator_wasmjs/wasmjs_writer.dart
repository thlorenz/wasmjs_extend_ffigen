import 'package:ffigen/src/code_generator/binding.dart';
import 'package:ffigen/src/code_generator/type.dart';
import 'package:ffigen/src/code_generator/utils.dart';
import 'package:ffigen/src/code_generator/writer.dart';

class WasmJsWriter extends Writer {
  late String _wasmInstance;
  late String _dartAsync;
  late String _dartConvert;
  late String _dartTyped;
  late String _wasmInterop;
  late String _opaqueClass;

  @override
  String get ffiLibraryPrefix => '';

  WasmJsWriter({
    required List<Binding> lookUpBindings,
    required List<Binding> noLookUpBindings,
    required String className,
    required bool dartBool,
    String? classDocComment,
    String? header,
  }) : super(
            lookUpBindings: lookUpBindings,
            noLookUpBindings: noLookUpBindings,
            className: className,
            dartBool: dartBool,
            classDocComment: classDocComment,
            header: header) {
    _wasmInstance = _resolveNameConflict(
      name: '_wasmInstance',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
    _dartAsync = _resolveNameConflict(
      name: 'dart_async',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
    _dartConvert = _resolveNameConflict(
      name: 'dart_convert',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
    _dartTyped = _resolveNameConflict(
      name: 'dart_typed',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
    _wasmInterop = _resolveNameConflict(
      name: 'wasm_interop',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
    _opaqueClass = _resolveNameConflict(
      name: 'Opaque',
      makeUnique: initialTopLevelUniqueNamer,
      markUsed: [initialTopLevelUniqueNamer],
    );
  }

  /// Resolved name conflict using [makeUnique] and marks the result as used in
  /// all [markUsed].
  String _resolveNameConflict({
    required String name,
    required UniqueNamer makeUnique,
    List<UniqueNamer> markUsed = const [],
  }) {
    final s = makeUnique.makeUnique(name);
    for (final un in markUsed) {
      un.markUsed(s);
    }
    return s;
  }

  @override
  String generate() {
    final s = StringBuffer();

    // Reset unique names to initial state.
    resetUniqueNamersNamers();

    // Write file header (if any).
    if (header != null) {
      s.write(header);
      s.write('\n');
    }

    // Write auto generated declaration.
    s.write(makeDoc(
        'AUTO GENERATED FILE, DO NOT EDIT.\n\nGenerated by `package:ffigen`.'));
    s.write('\n');

    // Imports
    s.write("import 'dart:async' as $_dartAsync;\n");
    s.write("import 'dart:convert' as $_dartConvert;\n");
    s.write("import 'dart:typed_data' as $_dartTyped;\n");
    s.write(
        "import 'package:wasm_interop/wasm_interop.dart' as $_wasmInterop;\n");

    if (lookUpBindings.isNotEmpty) {
      if (classDocComment != null) {
        s.write(makeDartDoc(classDocComment!));
      }

      // Write Library wrapper classs.
      s.write('class $className{\n');
      s.write('/// The symbol lookup function.\n');

      // Write lookup function
      s.write('T $lookupFuncIdentifier<T>(String name) {\n');
      s.write('  return $_wasmInstance.functions[name] as T;\n');
      s.write('}\n');

      // Instance field and constructor
      s.write('final $_wasmInterop.Instance $_wasmInstance;\n');
      s.write('$className(this._wasmInstance);\n');

      for (final b in lookUpBindings) {
        s.write(b.toBindingString(this).string);
      }

      // Static Initializers
      s.write('\n');
      s.write('static $className? _instance;\n');
      s.write('static $className get instance {\n');
      s.write('  assert(_instance != null,\n');
      s.write(
          '      "need to $className.init() before accessing instance");\n');
      s.write('  return _instance!;\n');
      s.write('}\n');
      s.write('\n');
      s.write(
          'static Future<$className> init($_dartTyped.Uint8List moduleData) async {\n');
      s.write(
          '  final $_wasmInterop.Instance instance = await $_wasmInterop.Instance.fromBytesAsync(moduleData);\n');
      s.write('  _instance = $className(instance);\n');
      s.write('  return $className.instance;\n');
      s.write('}\n');

      s.write('}\n\n');
    }

    writePointerAndOpaque(s);
    writeBuiltInNatives(s);
    return s.toString();
  }

  void writePointerAndOpaque(StringBuffer s) {
    s.writeln('// Base for Native Types and Opaque Structs');
    s.writeln('class $_opaqueClass {');
    s.writeln('  final int _address;');
    s.writeln('  int get address => _address;');
    s.writeln('  $_opaqueClass(this._address);');
    s.writeln('}\n');

    s.writeln('// FFI Pointer Replacement');
    s.writeln('class Pointer<T extends $_opaqueClass> {');
    s.writeln('  final T _opaque;');
    s.writeln('  Pointer._(this._opaque);');
    s.writeln('  factory Pointer.fromAddress(T opaque) {');
    s.writeln('    return Pointer._(opaque);');
    s.writeln('  }');
    s.writeln('  int get address => _opaque.address;');
    s.writeln('}');
  }

  void writeBuiltInNatives(StringBuffer s) {
    s.writeln('// Dart FFI Native Types');

    final uniquePrims = Type.primitives.values.map((x) => x.c).toSet();
    for (final prim in uniquePrims) {
      s.writeln('class $prim extends $_opaqueClass {');
      s.writeln('  $prim(int address): super(address);');
      s.writeln('}');
    }
  }
}
